{
	"id": "wenet_english_auction_with_norms_v1",
	"name": "English auction",
	"description": "An English auction is an open-outcry ascending dynamic auction. On the goal name is defined the item and on the goal description provide information of the item to sell.",
	"keywords": [
		"Auction",
		"Bid",
		"Sold"
	],
	"attributes": {
		"whom": {
			"type": "string",
			"description": "The type of users to participate on the auction. Can be 'any' user defined on the app, any of the 10 users closest to me ('closest'), any user into a 3 km near to me('neighbor'), any user into a 30 km near to me('villager'), or any user into a 300 km near to me('citizen')",
			"default": "any",
			"enum": [
				"any",
				"closest",
				"neighbor",
				"villager",
				"citizen"
			]
		},
		"automatic": {
			"attributes": {
				"type": "object",
				"nullable":"true",
				"description": "If this attribute is defined the aution is automatically executed.",
				"quorum": {
					"type": "integer",
					"description": "The minimum users that has to be on the auction to start it.",
					"default": 2,
					"minimum": 2
				},
				"delayToStart": {
					"type": "integer",
					"description": "The seconds to wait to start after the aucion has quorum.",
					"default": 10,
					"minimum": 1
				},
				"startPrice": {
					"type": "number",
					"description": "The initial price to start the auction.",
					"default": 0.01,
					"minimum": 0.01
				},
				"offerIncrement": {
					"type": "number",
					"description": "The percentage to increment the price after a bid is accepted.",
					"default": 0.05,
					"minimum": 0.01
				},
				"offerDelay": {
					"type": "integer",
					"description": "The seconds to have to wait to do a new offer.",
					"default": 3,
					"minimum": 1
				},
				"maxCalls": {
					"type": "integer",
					"description": "The seconds to have to wait to do a new offer.",
					"default": 3,
					"minimum": 1
				}
			}
		}
	},
	"transactions": {
		"enter": {
			"type": "object",
			"description": "Enter into the auction."
		},
		"exit": {
			"type": "object",
			"description": "Exit of the auction."
		},
		"bid": {
			"type": "object",
			"description": "Provide a bid over the aution item.",
			"properties": {
				"price": {
					"type": "number",
					"description": "The bidding price for the item that is on the auction."
				}
			}
		},
		"close": {
			"type": "object",
			"description": "Close the auction",
			"properties": {
				"reason": {
					"type": "string",
					"description": "Explains why the auction is cancelled."
				}
			}
		}
	},
	"callbacks": {
		"Error": {
			"description": "Inform that can not do an action over the task.",
			"type": "object",
			"properties": {
				"code": {
					"type": "string",
					"description": "The code that describe the error.",
					"enum": [
						"cannot_create_task_with_bad_startTime",
						"cannot_create_task_no_found_quorum",
						"cannot_enter_because_task_is_closed",
						"cannot_exit_because_task_is_closed",
						"cannot_bid_because_task_is_closed",
						"cannot_close_because_task_is_closed",
						"cannot_start_because_no_have_quorum"
					]
				},
				"taskId": {
					"type": "string",
					"description": "The identifier of the task where the error happens.",
					"example": "1"
				}
			}
		},
		"NewAuction": {
			"description": "Inform about an auction that the user can participate.",
			"properties": {
				"taskId": {
					"type": "string",
					"description": "The identifier of the task where the auction will be done",
					"example": "1"
				}
			}
		},
		"StartAuction": {
			"description": "Inform taht the auciton has started.",
			"properties": {
				"taskId": {
					"type": "string",
					"description": "The identifier of the task where the auction has sarted",
					"example": "1"
				}
			}
		},
		"Offer": {
			"description": "Inform that the auciton has started.",
			"properties": {
				"taskId": {
					"type": "string",
					"description": "The identifier of the task associated to the auction",
					"example": "1"
				},
				"price": {
					"type": "number",
					"description": "The prixe to buy the item.",
					"example": "10.20"
				}
			}
		},
		"LastCall": {
			"description": "Inform that it is the last oportinity to buy the item.",
			"properties": {
				"taskId": {
					"type": "string",
					"description": "The identifier of the task associated to the auction",
					"example": "1"
				},
				"price": {
					"type": "number",
					"description": "The price to buy the item.",
					"example": "10.20"
				}
			}
		},
		"Sold": {
			"description": "Inform that the item has sold.",
			"properties": {
				"taskId": {
					"type": "string",
					"description": "The identifier of the task associated to the auction",
					"example": "1"
				},
				"price": {
					"type": "number",
					"description": "The price that the item is sold.",
					"example": "10.20"
				},
				"buyerId": {
					"type": "string",
					"description": "The identifier of the user that has bought the item",
					"example": "1lgf786"
				}
			}
		}
	},
	"norms": [
		{
			"whenever": "is_received_created_task() and get_task_attribute_value(StartTime,startTime) and is_now_greater_than_or_equal_to(StartTime)",
			"thenceforth": "close_task() and send_error('cannot_create_task_with_bad_startTime')",
			"ontology": ":- dynamic send_error/1. send_error(Code) :- get_task_id(TaskId), send_user_message('Error',json([code=Code,taskId=TaskId]))."
		},
		{
			"whenever": "get_whom_users(Users) and get_task_attribute_value(StartTime,startTime) and is_now_less_than(StartTime) and get_task_attribute_value(Quorum,quorum) and length(Users,Length) and <(Length,Quorum) and get_task_id(TaskId)",
			"thenceforth": "close_task() and send_error('cannot_create_task_no_found_quorum')",
			"ontology": ":- dynamic get_whom_users/1. get_whom_users(Users) :- is_received_created_task(), get_task_attribute_value(Whom,whom),( Whom = 'any' -> get_app_users_except_me(Users);true),( Whom = 'closest' -> get_closest_users_to_me(Users);true),( Whom = 'neighbor' -> get_app_users_near_me(Users,0,3000);true),( Whom = 'villager' -> get_app_users_near_me(Users,0,30000);true),( Whom = 'citizen' -> get_app_users_near_me(Users,0,300000);true),!,retractall(get_whom_users(_)),asserta(get_whom_users(Users))."
		},
		{
			"whenever": "get_whom_users(Users) and get_task_attribute_value(StartTime,startTime) and is_now_less_than(StartTime) and get_task_attribute_value(Quorum,quorum) and length(Users,Length) and >=(Length,Quorum) and get_now(Now)",
			"thenceforth": "add_created_transaction() and put_community_state_attribute(unanswered,Users) and send_messages(Users,'newAuction',@(null)) and wenet_math(Delay,max(0,StartTime - Now)) and send_event('startAuction',@(null),Delay)"
		},
		{
			"whenever": "is_received(_,'newAuction',_) and get_task_id(TaskId)",
			"thenceforth": "send_user_message('NewAuction',json([taskId=TaskId]))"
		},
		{
			"whenever": "is_received_do_transaction('enter',_) and is_task_closed()",
			"thenceforth": "send_error('cannot_enter_because_task_is_closed')"
		},
		{
			"whenever": "is_received_do_transaction('exit',_) and is_task_closed()",
			"thenceforth": "send_error('cannot_exit_because_task_is_closed')"
		},
		{
			"whenever": "is_received_do_transaction('bid',_) and is_task_closed()",
			"thenceforth": "send_error('cannot_bid_because_task_is_closed')"
		},
		{
			"whenever": "is_received_do_transaction('close',_) and is_task_closed()",
			"thenceforth": "send_error('cannot_close_because_task_is_closed')"
		},
		{
			"whenever": "is_received(_,'startAuction',_) and not(is_task_closed()) and get_community_state_attribute(Entered,'entered',[]) and get_task_attribute_value(Quorum,quorum) and length(Entered,Length) and <(Length,Quorum)",
			"thenceforth": "close_task() and send_error('cannot_start_because_no_have_quorum') and send_messages(Entered,'cannot_start_because_no_have_quorum',@(null))"
		},
		{
			"whenever": "is_received(_,'cannot_start_because_no_have_quorum',_)",
			"thenceforth": "send_error('cannot_start_because_no_have_quorum')"
		},
		{
			"whenever": "is_received(_,'startAuction',_) and not(is_task_closed()) and get_community_state_attribute(Entered,'entered',[]) and get_task_attribute_value(Quorum,quorum) and length(Entered,Length) and >=(Length,Quorum) and get_task_id(TaskId) and get_task_attribute_value(StartPrice,startPrice)",
			"thenceforth": "send_user_message('StartAuction',json([taskId=TaskId])) and send_messages(Entered,'StartAuction',@(null)) and send_event('Offer',json([price=StartPrice]))"
		},
		{
			"whenever": "is_received(_,'StartAuction',_) and get_task_id(TaskId)",
			"thenceforth": "send_user_message('StartAuction',json([taskId=TaskId]))"
		},
		{
			"whenever": "is_event('Offer',json([price=Price])) and get_community_state_attribute(LastPrice,'lastPrice',0) and get_community_state_attribute(Call,'call',0) and =<(Call,3) and get_task_id(TaskId) and get_community_state_attribute(Entered,'entered',[])",
			"thenceforth": "send_user_message('Offer',json([taskId=TaskId])) and send_messages(Entered,'Offer',json([price=Price])) and send_event('startAuction',@(null),Delay)"
		},
		{
			"whenever": "is_event('Offer',json([price=Price])) and get_community_state_attribute(LastPrice,'lastPrice',0) and get_community_state_attribute(Call,'call',0) and =<(Call,3) and get_task_id(TaskId) and get_community_state_attribute(Entered,'entered',[])",
			"thenceforth": "send_user_message('Offer',json([taskId=TaskId])) and send_messages(Entered,'Offer',json([price=Price])) and send_event('startAuction',@(null),Delay)"
		}
	]
}